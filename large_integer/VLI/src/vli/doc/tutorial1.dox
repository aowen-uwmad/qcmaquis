/**
\page tutorial Tutorial 1, construct a VLI number

The first tutorial illustrates how create VLI numbers. First, as usual C++ program 
the library needs an #include "vli.hpp", as following

\code
#include <iostream>
#include "vli.hpp" 

int main(int argc, char * argv[]){
    vli<128> a;
    std::cout << a << std::endl;
    std::cout << std::hex << a <<  std::endl;
}
\endcode

The code needs the include path of the library VLI and boost, and a link to the library VLI : 

\code
    g++ -I/PATH_INCLUDE_BOOST -I/PATH_INCLUDE_VLI main.cpp -L/PATH_LIBRARY_VLI -lvli
\endcode

The output will be : 

\code
   0 // for the decimal form 
   0 0 // for the hexadecimal form, by default the hexadecimal prints all entries of the VLI number
\endcode

This example is not very significative, considering now the following initialization of the number a: 

\code
    vli<132> a(1);
\endcode

The VLI library will fit the number into a multiple of 64-bit, thus the container will be 192 bits.

The print under hexadecimal mode gives (little endian form): 

\code
   0 0 1// for the hexadecimal form, by default the hexadecimal prints all entries of the VLI number
\endcode

Although the library will select a good container size, we recommend a multiple of 64-bit to facilitate the utilization of the arithmetic operations 

Now if we decided to create a negative VLI :  

\code
    vli<128> a(-1);
\endcode

Negative numbers are constructed with the two complementary method, thus the hexadecimal print will be : 

\code
    0xffffffffffffffff 0xffffffffffffffff
\endcode

The last possibility to initiate a number is the operators brackets [], as they allow a direct access to the container.

\code
   vli<256> a;
   a[0] = 1;
   a[2] = 3;
\endcode

it will give

\code
    0 3 0 1
\endcode

\note
This last mode of initialization should be avoid, it is more reserved for developers who are looking for special features.
\endnote


*/
