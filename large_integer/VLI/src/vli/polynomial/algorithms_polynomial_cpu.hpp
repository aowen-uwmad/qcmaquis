/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Timothee Ewart - University of Geneva, 
*Andreas Hehn - Swiss Federal Institute of technology Zurich 
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#ifndef VLI_ALGORITHMS_POLYNOMIAL
#define VLI_ALGORITHMS_POLYNOMIAL

namespace vli{ 

template<class Vli, unsigned int Order>
class polynomial;
    
template<class BaseInt, std::size_t Size>
class vli_cpu;
    
    
/** First Algo based on block : n threads possible **/    
template <class BaseInt, std::size_t Size, unsigned int Order>
void triangle_up(unsigned int block_ai, int block_bj,
                 polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,    
                 polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                 polynomial<vli_cpu<BaseInt, Size>, Order> const & p2)
{
    unsigned int n(0);
    unsigned int offset_block_ai = block_ai*Order;
    unsigned int offset_block_bj = block_bj*Order;
    
    for(unsigned int i = 0; i < Order-1; ++i){
        for(unsigned int j = n; j < Order-1; ++j){
            muladd(result.coeffs_[(offset_block_ai+offset_block_bj)*2+j], p1.coeffs_[j-n+offset_block_ai],p2.coeffs_[n+offset_block_bj]);
        }    
        n++;
    }        
};

template <class BaseInt, std::size_t Size, unsigned int Order>
void diag(unsigned block_ai, unsigned block_bj,
          polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,    
          polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
          polynomial<vli_cpu<BaseInt, Size>, Order> const & p2)
{
    unsigned int OrderMinusOne = Order-1;
    unsigned int offset_block_ai = block_ai*Order;
    unsigned int offset_block_bj = block_bj*Order;    
    
    for(unsigned int i = 0; i < Order; ++i)
        muladd(result.coeffs_[(offset_block_ai+offset_block_bj)*2+OrderMinusOne], p1.coeffs_[offset_block_bj+Order-1-i],p2.coeffs_[offset_block_ai+i]);
}

template <class BaseInt, std::size_t Size, unsigned int Order>
void triangle_down(unsigned int block_ai, unsigned int block_bj, 
                   polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,    
                   polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                   polynomial<vli_cpu<BaseInt, Size>, Order> const & p2)
{
    unsigned int n(0);
    unsigned int offset_block_ai = (block_ai+1)*(Order)-1;
    unsigned int offset_block_bj = (block_bj+1)*(Order)-1;
    
    for(unsigned int i = 0; i < Order-1; ++i){
        for(unsigned int j = n; j < Order-1; ++j){
            muladd(result.coeffs_[(offset_block_ai+offset_block_bj)*2-2*Order+2-j], p1.coeffs_[offset_block_ai+n-j],p2.coeffs_[offset_block_bj-n]);
        }    
        n++;
    }        
}

template <class BaseInt, std::size_t Size, unsigned int Order>
void block_algo(int i, int j, 
                polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,    
                polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                polynomial<vli_cpu<BaseInt, Size>, Order> const & p2)
{
    triangle_up(i,j,result,p1,p2);  
    diag(i,j,result,p1,p2);
    triangle_down(i,j,result,p1,p2);
}
    
//pass block algo function
template <class BaseInt, std::size_t Size, unsigned int Order>
void multiply_assign_block(polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,
                           polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                           polynomial<vli_cpu<BaseInt, Size>, Order> const & p2){
    // first PASS, half top right corner, 
    unsigned int n(0);
    for(unsigned int i=0;i< Order;++i){ // i will be a thread here, independence loop
        for(unsigned int j=0; j<=n; ++j){
            block_algo(j,n-j,result,p1,p2);
        }   
        n++; // thread num
    }   
        
    // second PASS, half bottom left corner, 
    n=1;
    for(unsigned int i=1; i<Order;++i){  // i will be a thread here, independence loop
        for(unsigned int j=n; j<Order; ++j){
            block_algo(j,Order-j+n-1,result,p1,p2);
        }   
        n++; // thread num
    }   
}
    
/** second Algo  based on diagonals n*n symetries **/    
template <class BaseInt, std::size_t Size, unsigned int Order>
void diagonal_up(unsigned int n,
                polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,    
                polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                polynomial<vli_cpu<BaseInt, Size>, Order> const & p2)
{
    unsigned int qa,ra,qb,rb,pos; // find all indexes
    
    for(int i(0); i <= n; i++){
        qa = i/Order;
        ra = i%Order;
        qb = (n-i)/Order;
        rb = (n-i)%Order;
        pos = 2*(qa+qb)*Order + (ra+rb);

        muladd(result.coeffs_[pos], p1.coeffs_[(n-i)],p2.coeffs_[i]);
    }
}
    
template <class BaseInt, std::size_t Size, unsigned int Order>
void diagonal_down(unsigned int n,
                   polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,    
                   polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                   polynomial<vli_cpu<BaseInt, Size>, Order> const & p2)
{    
    int qa,ra,qb,rb,pos; // find all indexes

    int j = Order*Order-1;
 
    for(int i(Order*Order-n+1); i < Order*Order; i++){
        qa = i/Order;
        ra = i%Order;
        qb = j/Order;
        rb = j%Order;
        pos = 2*(qa+qb)*Order + (ra+rb);

        muladd(result.coeffs_[pos], p1.coeffs_[j],p2.coeffs_[i]);
        j--;        
    }    
}   

//pass diag algo function    
template <typename BaseInt, std::size_t Size, unsigned int Order>
void multiply_assign_diagonal(polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result,
                                polynomial<vli_cpu<BaseInt, Size>, Order> const & p1,
                                polynomial<vli_cpu<BaseInt, Size>, Order> const & p2){
    
    for( int i(0); i < Order*Order ; ++i){
        diagonal_up<BaseInt,Size,Order>(i,result,p1,p2);     //first pass
        diagonal_down<BaseInt,Size,Order>(Order*Order - i,result,p1,p2);   //second pass    
    }
    
    }
} // end namespace

#endif