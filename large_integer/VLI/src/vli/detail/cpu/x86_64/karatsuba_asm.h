/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Timothee Ewart - University of Geneva, 
*Andreas Hehn - Swiss Federal Institute of technology Zurich.
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#ifndef VLI_KARATSUBA_ASM_H
#define VLI_KARATSUBA_ASM_H

namespace vli {
    namespace detail {
    
    template <std::size_t NumBits>
    void inline KA_add(boost::uint64_t* x, boost::uint64_t const* y){
        asm("addq  %1, %0;" :"+r"(x[0]):"g"(y[0]):"cc");
        for(int i(1); i < (NumBits>>6);++i)
            asm("adcq  %1, %0;" :"+r"(x[i]):"g"(y[i]):"cc");
    };
   
    template <std::size_t NumBits>
    void inline KA_sub(boost::uint64_t* x, boost::uint64_t const* y){
        asm("subq  %1, %0;" :"+r"(x[0]):"g"(y[0]):"cc");
        for(int i(1); i < (NumBits>>6);++i)
            asm("sbbq  %1, %0;" :"+r"(x[i]):"g"(y[i]):"cc");
    };
   
    template <std::size_t NumBits>
    struct KA_helper{
        inline static vli<2*NumBits> KA_algo(vli<NumBits> const&  vli_a, vli<NumBits> const& vli_b){
            vli<NumBits/2> x1(vli_a,copy_lsb_tag()),x2(vli_a,copy_msb_tag());
            vli<NumBits/2> y1(vli_b,copy_lsb_tag()),y2(vli_b,copy_msb_tag());
            vli<NumBits/2> x1x2(x1);
            vli<NumBits/2> y1y2(y1);
            vli<NumBits> u,v,w;
            u = KA_helper<NumBits/2>::KA_algo(x2,y2);
            v = KA_helper<NumBits/2>::KA_algo(x1,y1);
            KA_add<NumBits/2>(&x1x2[0],&x2[0]);
            KA_add<NumBits/2>(&y1y2[0],&y2[0]);
            w = KA_helper<NumBits/2>::KA_algo(x1x2,y1y2);
            KA_sub<NumBits>(&w[0],&u[0]);
            KA_sub<NumBits>(&w[0],&v[0]);
            vli<2*NumBits> tmp_res0(w,copy_right_shift_tag());
            vli<2*NumBits> tmp_res1(u,v,copy_right_shift_tag());
            KA_add<2*NumBits>(&tmp_res0[0],&tmp_res1[0]);
            return tmp_res0;
        };
    };
   
    template <>
    struct KA_helper<64>{
        inline static vli<128>  KA_algo(vli<64> const& vli_a, vli<64> const& vli_b){//
            vli<128> vli_res;
            // =a means rax for lower part, =d means rdx for the higher part, = for writing
            asm("mulq %3;" :"=a"(vli_res[0]), "=d"(vli_res[1]) :"%0" (vli_a[0]), "r"(vli_b[0]): "cc");
            return vli_res;
        }
    };

    }
}

#endif
