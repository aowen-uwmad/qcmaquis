/*
 * Copyright Institute for Theoretical Physics, ETH Zurich 2015.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef USE_LIBSCI
#ifndef AMBIENT_CONTAINER_NUMERIC_BINDINGS_LIBSCI
#define AMBIENT_CONTAINER_NUMERIC_BINDINGS_LIBSCI

#include <dlfcn.h>
#define THROW_IF_NOT_FOUND if(dlerror()) throw std::runtime_error("Error: cannot load a symbol from libsci");

namespace ambient { inline namespace numeric {

    class libsci_acc {
    private:
        libsci_acc(){
            void* handle = dlopen("libsci_acc_cray_nv35.so", RTLD_LAZY | RTLD_DEEPBIND);
            if(!handle) throw std::runtime_error("Error: cannot open libsci_acc_cray_nv35.so!");
            dlerror();

            libsci_acc_init      = (decltype(libsci_acc_init     )) dlsym(handle, "libsci_acc_init");      THROW_IF_NOT_FOUND
            libsci_acc_finalize  = (decltype(libsci_acc_finalize )) dlsym(handle, "libsci_acc_finalize");  THROW_IF_NOT_FOUND
            libsci_acc_HostAlloc = (decltype(libsci_acc_HostAlloc)) dlsym(handle, "libsci_acc_HostAlloc"); THROW_IF_NOT_FOUND
            libsci_acc_HostFree  = (decltype(libsci_acc_HostFree )) dlsym(handle, "libsci_acc_HostFree");  THROW_IF_NOT_FOUND
            libsci_syev          = (decltype(libsci_syev         )) dlsym(handle, "dsyev");                THROW_IF_NOT_FOUND
            libsci_heev          = (decltype(libsci_heev         )) dlsym(handle, "zheev");                THROW_IF_NOT_FOUND

            dlclose(handle);
            libsci_acc_init();
            std::cout << "ambient: using partial libsci support\n\n";
        }
       ~libsci_acc(){
            libsci_acc_finalize();
        }
    public:
        static void* malloc(size_t sz){
            void* ptr; libsci_acc::weak_instance<void>::w.libsci_acc_HostAlloc(&ptr, sz);
            return ptr;
        }
        static void free(void* ptr){
            libsci_acc::weak_instance<void>::w.libsci_acc_HostFree(ptr);
        }
    public:
        template<class T>
        struct weak_instance {
            static libsci_acc w;
        };
    private:
        void(*libsci_acc_init)();
        void(*libsci_acc_finalize)();
        int (*libsci_acc_HostAlloc)(void**,size_t);
        int (*libsci_acc_HostFree)( void* );
    public:
        void(*libsci_syev)(char, char, int, double*, int, double*, double*, int, int*);
        void(*libsci_heev)(char, char, int, double*, int, double*, double*, int, double*, int*);
    };

    template<class T>
    libsci_acc libsci_acc::weak_instance<T>::w;

} }

namespace ambient { inline namespace numeric { namespace libsci {

    template<class T>
    struct lapack;

    template<>
    struct lapack<double> {
       typedef double T;
       static void heev(const char* jobz, const char* uplo, const int* n, T* a, const int* lda, T* w, T* wkopt, int* lwork, int* info){
            libsci_acc::weak_instance<void>::w.libsci_syev(*jobz, *uplo, *n, a, *lda, w, wkopt, *lwork, info);
            *lwork = (int)(*wkopt);
            double* work = (double*)libsci_acc::malloc( (*lwork)*sizeof(double) );
            libsci_acc::weak_instance<void>::w.libsci_syev(*jobz, *uplo, *n, a, *lda, w, work, *lwork, info);
            libsci_acc::free(work);
       }
    };

    template<>
    struct lapack<std::complex<double> > {
       typedef std::complex<double> T;
       static void heev(const char* jobz, const char* uplo, const int* n, T* a, const int* lda, typename T::value_type* w, T* wkopt, int* lwork, int* info){
            double* rwork = (double*)libsci_acc::malloc(sizeof(double)*std::max(1,3*(*n)-2)); // ref MKL manual
            libsci_acc::weak_instance<void>::w.libsci_heev(*jobz, *uplo, *n, (double*)a, *lda, w, (double*)wkopt, *lwork, rwork, info);
            *lwork = (int)(wkopt->real());
            double* work = (double*)libsci_acc::malloc( (*lwork)*sizeof(std::complex<double>) );
            libsci_acc::weak_instance<void>::w.libsci_heev(*jobz, *uplo, *n, (double*)a, *lda, w, work, *lwork, rwork, info);
            libsci_acc::free(work);
            libsci_acc::free(rwork);
       }
    };

} } }

#undef THROW_IF_NOT_FOUND
#endif
#endif
