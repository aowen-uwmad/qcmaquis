/*
 * Copyright Institute for Theoretical Physics, ETH Zurich 2014.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef AMBIENT_CONTAINER_NUMERIC_BINDINGS_EXPERIMENTAL
#define AMBIENT_CONTAINER_NUMERIC_BINDINGS_EXPERIMENTAL

#define MKL_INT int
#define MKL_Complex16 std::complex<double>

extern "C" {

    void dlarfg( const MKL_INT* n, double* alpha, double* x, const MKL_INT* incx, 
                 double* tau );

    void zlarfg( const MKL_INT* n, MKL_Complex16* alpha, MKL_Complex16* x, 
                 const MKL_INT* incx, MKL_Complex16* tau );

    void dgebd2( const MKL_INT* m, const MKL_INT* n, double* a, const MKL_INT* lda, 
                 double* d, double* e, double* tauq, double* taup, double* work,
                 MKL_INT* info );

    void zgebd2( const MKL_INT* m, const MKL_INT* n, MKL_Complex16* a, 
                 const MKL_INT* lda, double* d, double* e, MKL_Complex16* tauq,
                 MKL_Complex16* taup, MKL_Complex16* work, MKL_INT* info );

    void dgebrd( const MKL_INT* m, const MKL_INT* n, double* a, const MKL_INT* lda, 
                 double* d, double* e, double* tauq, double* taup, double* work,
                 const MKL_INT* lwork, MKL_INT* info );

    void zgebrd( const MKL_INT* m, const MKL_INT* n, MKL_Complex16* a, 
                 const MKL_INT* lda, double* d, double* e, MKL_Complex16* tauq,
                 MKL_Complex16* taup, MKL_Complex16* work, const MKL_INT* lwork,
                 MKL_INT* info );

    void dorgbr( const char* vect, const MKL_INT* m, const MKL_INT* n, 
                 const MKL_INT* k, double* a, const MKL_INT* lda,
                 const double* tau, double* work, const MKL_INT* lwork,
                 MKL_INT* info );

    void zungbr( const char* vect, const MKL_INT* m, const MKL_INT* n, 
                 const MKL_INT* k, MKL_Complex16* a, const MKL_INT* lda,
                 const MKL_Complex16* tau, MKL_Complex16* work,
                 const MKL_INT* lwork, MKL_INT* info );

    void dgbbrd( const char* vect, const MKL_INT* m, const MKL_INT* n, 
                 const MKL_INT* ncc, const MKL_INT* kl, const MKL_INT* ku,
                 double* ab, const MKL_INT* ldab, double* d, double* e, double* q,
                 const MKL_INT* ldq, double* pt, const MKL_INT* ldpt, double* c,
                 const MKL_INT* ldc, double* work, MKL_INT* info );

    void zgbbrd( const char* vect, const MKL_INT* m, const MKL_INT* n, 
                 const MKL_INT* ncc, const MKL_INT* kl, const MKL_INT* ku,
                 MKL_Complex16* ab, const MKL_INT* ldab, double* d, double* e,
                 MKL_Complex16* q, const MKL_INT* ldq, MKL_Complex16* pt,
                 const MKL_INT* ldpt, MKL_Complex16* c, const MKL_INT* ldc,
                 MKL_Complex16* work, double* rwork, MKL_INT* info );

    void dbdsqr( const char* uplo, const MKL_INT* n, const MKL_INT* ncvt, 
                 const MKL_INT* nru, const MKL_INT* ncc, double* d, double* e,
                 double* vt, const MKL_INT* ldvt, double* u, const MKL_INT* ldu,
                 double* c, const MKL_INT* ldc, double* work, MKL_INT* info );

    void zbdsqr( const char* uplo, const MKL_INT* n, const MKL_INT* ncvt, 
                 const MKL_INT* nru, const MKL_INT* ncc, double* d, double* e,
                 MKL_Complex16* vt, const MKL_INT* ldvt, MKL_Complex16* u,
                 const MKL_INT* ldu, MKL_Complex16* c, const MKL_INT* ldc,
                 double* rwork, MKL_INT* info );
}

#undef MKL_INT
#undef MKL_Complex16

namespace ambient { namespace numeric { namespace mkl {

    template<class T>
    struct lapack_exp;

    template<>
    struct lapack_exp<double> {
       typedef double T;
       static void larfg(const int *n, T* alfa, T* x, int *incx, T* tau){
           dlarfg(n, alfa, x, incx, tau); 
       }

       static void gebd2(const int* m, const int* n, T* a, const int* lda, T* d, T* e, T* tauq, T* taup, T* work, int* info){
           dgebd2(m ,n, a, lda, d, e, tauq, taup, work, info);
           assert( *info == 0 );
       }

       static void gebrd(const int* m, const int* n, T* a, const int* lda, T* d, T* e, T* tauq, T* taup, T* work, const int* lwork, int* info){
           dgebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info);  
           assert( *info == 0 );
       }

       static void orgbr(const char* vect, const int* m, const int* n, const int* k, T* a, const int* lda, const T* tau, T* work, const int* lwork, int* info){
           dorgbr(vect, m, n, k, a, lda, tau, work, lwork, info);
           assert( *info == 0 );
       }

       static void gbbrd (const char* vect, const int* m, const int* n, const int* ncc, const int* kl, const int* ku, T* ab, const int* ldab, T* d, T* e, T* q, const int* ldq, T* pt, const int* ldpt, T* c, const int* ldc, T* work, int* info ){
           dgbbrd(vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, info);
           assert( *info == 0 );
       }
 
       static void bdsqr(const char* uplo, const int* n, const int* ncvt, const int* nru, const int* ncc, T* d, T* e, T* vt, const int* ldvt, T* u, const int* ldu, T* c, const int* ldc, T* work, int* info ){
           dbdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work, info);
           assert( *info == 0 );
       }
    };

    template<>
    struct lapack_exp<std::complex<double> > {
       typedef std::complex<double> T;
       static void larfg(const int *n, T* alfa, T* x, int *incx, T* tau){
           zlarfg(n, alfa, x, incx, tau); 
       }

       static void gebd2(const int* m, const int* n, T* a, const int* lda, T* d, T* e, T* tauq, T* taup, T* work, int* info){
           zgebd2(m ,n, a, lda, d, e, tauq, taup, work, info);
           assert( *info == 0 );
       }

       static void gebrd (const int* m, const int* n, T* a, const int* lda, T * d, T* e, T* tauq, T* taup, T* work,
                        //  typename T::value_type * d, typename T::value_type* e, T* tauq, T* taup, T* work, <------ the good one
                          const int* lwork, int* info){
           throw std::runtime_error("Error: fix the signature and the mix double/complex for TE");
           //zgebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info);  
       }

       static void orgbr(const char* vect, const int* m, const int* n, const int* k, T* a, const int* lda, const T* tau, T* work, const int* lwork, int* info){
           zungbr(vect, m, n, k, a, lda, tau, work, lwork, info); // double signature != complex signature
       }

       static void gbbrd (const char* vect, const int* m, const int* n, const int* ncc, const int* kl, const int* ku, T* ab, const int* ldab, T* d, T* e, T* q, const int* ldq, T* pt, const int* ldpt, T* c, const int* ldc, T* work, int* info ){
           throw std::runtime_error("Error: fix I need one more buffer for complex");
           //zgbbrd(vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, info);
       }

       static void bdsqr(const char* uplo, const int* n, const int* ncvt, const int* nru, const int* ncc, T* d, T* e, T* vt, const int* ldvt, T* u, const int* ldu, T* c, const int* ldc, T* work, int* info ){
           throw std::runtime_error("Error: fix the signature and the mix double/complex for TE");
           //zbdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work, info);
       }
    };

} } }

#endif
