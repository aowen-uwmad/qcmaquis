template< typename T0 , void(*fp)( T0& )>
struct kernel_inliner<void(*)( T0& ), fp> {
    static const size_t argc = 1;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , void(*fp)( pinned T0& )> struct kernel_inliner<void(*)( pinned T0& ), fp> { static const size_t argc = 1; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , void(*fp)( T0& , T1& )>
struct kernel_inliner<void(*)( T0& , T1& ), fp> {
    static const size_t argc = 2;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , void(*fp)( pinned T0& , T1& )> struct kernel_inliner<void(*)( pinned T0& , T1& ), fp> { static const size_t argc = 2; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , void(*fp)( T0& , pinned T1& )> struct kernel_inliner<void(*)( T0& , pinned T1& ), fp> { static const size_t argc = 2; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };





template< typename T0 , typename T1 , typename T2 , void(*fp)( T0& , T1& , T2& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& ), fp> {

    static const size_t argc = 3;

    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }

};

template< typename T0 , typename T1 , typename T2 , void(*fp)( pinned T0& , T1& , T2& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& ), fp> { static const size_t argc = 3; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , void(*fp)( T0& , pinned T1& , T2& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& ), fp> { static const size_t argc = 3; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , void(*fp)( T0& , T1& , pinned T2& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& ), fp> { static const size_t argc = 3; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , typename T2 , typename T3 , void(*fp)( T0& , T1& , T2& , T3& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& ), fp> {
    static const size_t argc = 4;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , typename T2 , typename T3 , void(*fp)( pinned T0& , T1& , T2& , T3& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& , T3& ), fp> { static const size_t argc = 4; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , void(*fp)( T0& , pinned T1& , T2& , T3& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& , T3& ), fp> { static const size_t argc = 4; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , void(*fp)( T0& , T1& , pinned T2& , T3& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& , T3& ), fp> { static const size_t argc = 4; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , void(*fp)( T0& , T1& , T2& , pinned T3& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , pinned T3& ), fp> { static const size_t argc = 4; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , marked info<T3>::typed::revised(o->arguments[3], o->revisions[3]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , void(*fp)( T0& , T1& , T2& , T3& , T4& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& ), fp> {
    static const size_t argc = 5;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , void(*fp)( pinned T0& , T1& , T2& , T3& , T4& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& , T3& , T4& ), fp> { static const size_t argc = 5; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , void(*fp)( T0& , pinned T1& , T2& , T3& , T4& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& , T3& , T4& ), fp> { static const size_t argc = 5; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , void(*fp)( T0& , T1& , pinned T2& , T3& , T4& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& , T3& , T4& ), fp> { static const size_t argc = 5; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , void(*fp)( T0& , T1& , T2& , pinned T3& , T4& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , pinned T3& , T4& ), fp> { static const size_t argc = 5; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , marked info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , void(*fp)( T0& , T1& , T2& , T3& , pinned T4& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , pinned T4& ), fp> { static const size_t argc = 5; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , marked info<T4>::typed::revised(o->arguments[4], o->revisions[4]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& ), fp> {
    static const size_t argc = 6;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , void(*fp)( pinned T0& , T1& , T2& , T3& , T4& , T5& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& , T3& , T4& , T5& ), fp> { static const size_t argc = 6; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , void(*fp)( T0& , pinned T1& , T2& , T3& , T4& , T5& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& , T3& , T4& , T5& ), fp> { static const size_t argc = 6; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , void(*fp)( T0& , T1& , pinned T2& , T3& , T4& , T5& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& , T3& , T4& , T5& ), fp> { static const size_t argc = 6; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , void(*fp)( T0& , T1& , T2& , pinned T3& , T4& , T5& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , pinned T3& , T4& , T5& ), fp> { static const size_t argc = 6; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , marked info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , void(*fp)( T0& , T1& , T2& , T3& , pinned T4& , T5& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , pinned T4& , T5& ), fp> { static const size_t argc = 6; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , marked info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , void(*fp)( T0& , T1& , T2& , T3& , T4& , pinned T5& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , pinned T5& ), fp> { static const size_t argc = 6; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , marked info<T5>::typed::revised(o->arguments[5], o->revisions[5]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& ), fp> {
    static const size_t argc = 7;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& ), fp> { static const size_t argc = 7; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& ), fp> { static const size_t argc = 7; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& ), fp> { static const size_t argc = 7; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& ), fp> { static const size_t argc = 7; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , marked info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& ), fp> { static const size_t argc = 7; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , marked info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& ), fp> { static const size_t argc = 7; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , marked info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& ), fp> { static const size_t argc = 7; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , marked info<T6>::typed::revised(o->arguments[6], o->revisions[6]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& ), fp> {
    static const size_t argc = 8;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , marked info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , marked info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , marked info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , marked info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& ), fp> { static const size_t argc = 8; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , marked info<T7>::typed::revised(o->arguments[7], o->revisions[7]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& ), fp> {
    static const size_t argc = 9;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , marked info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , marked info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , marked info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , marked info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , marked info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& ), fp> { static const size_t argc = 9; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , marked info<T8>::typed::revised(o->arguments[8], o->revisions[8]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )>
struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& ), fp> {
    static const size_t argc = 10;
    template<typename K>
    static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){
        o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o);
        ambient::controller.push(o);
    }
    static inline void invoke(sfunctor* o){
        fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) );
    }
    static inline void cleanup(sfunctor* o){
        info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]);
    }
    static inline void weight(cfunctor* o){
        info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o);
    }
    static inline void place(sfunctor* o){
        info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o);
    }
    static inline bool pretend(cfunctor* o){
        o->lock();
        o->workload--;
        o->unlock();
        if(!o->workload) return false;
        return true;
    }
    static inline void l_check_complete(cfunctor* o){
        o->lock();
        if(o->workload == 1) controller.execute_free_mod(o);
        else o->workload--;
        o->unlock();
    }
    static inline void c_check_complete(cfunctor* o){
        o->check_complete();
    }
};
template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )> struct kernel_inliner<void(*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( marked info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )> struct kernel_inliner<void(*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , marked info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )> struct kernel_inliner<void(*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , marked info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , marked info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , marked info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , marked info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , marked info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , marked info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , marked info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } }; template< typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , void(*fp)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& )> struct kernel_inliner<void(*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& ), fp> { static const size_t argc = 10; template<typename K> static inline void latch(kernel_dispatch<K>* o, T0& arg0 , T1& arg1 , T2& arg2 , T3& arg3 , T4& arg4 , T5& arg5 , T6& arg6 , T7& arg7 , T8& arg8 , T9& arg9 ){ o->arguments[0] = (void*)info<T0>::typed::pointer(arg0); o->revisions[0] = info<T0>::typed::modify(const_cast<T0&>(info<T0>::typed::dereference(o->arguments[0])), o); o->arguments[1] = (void*)info<T1>::typed::pointer(arg1); o->revisions[1] = info<T1>::typed::modify(const_cast<T1&>(info<T1>::typed::dereference(o->arguments[1])), o); o->arguments[2] = (void*)info<T2>::typed::pointer(arg2); o->revisions[2] = info<T2>::typed::modify(const_cast<T2&>(info<T2>::typed::dereference(o->arguments[2])), o); o->arguments[3] = (void*)info<T3>::typed::pointer(arg3); o->revisions[3] = info<T3>::typed::modify(const_cast<T3&>(info<T3>::typed::dereference(o->arguments[3])), o); o->arguments[4] = (void*)info<T4>::typed::pointer(arg4); o->revisions[4] = info<T4>::typed::modify(const_cast<T4&>(info<T4>::typed::dereference(o->arguments[4])), o); o->arguments[5] = (void*)info<T5>::typed::pointer(arg5); o->revisions[5] = info<T5>::typed::modify(const_cast<T5&>(info<T5>::typed::dereference(o->arguments[5])), o); o->arguments[6] = (void*)info<T6>::typed::pointer(arg6); o->revisions[6] = info<T6>::typed::modify(const_cast<T6&>(info<T6>::typed::dereference(o->arguments[6])), o); o->arguments[7] = (void*)info<T7>::typed::pointer(arg7); o->revisions[7] = info<T7>::typed::modify(const_cast<T7&>(info<T7>::typed::dereference(o->arguments[7])), o); o->arguments[8] = (void*)info<T8>::typed::pointer(arg8); o->revisions[8] = info<T8>::typed::modify(const_cast<T8&>(info<T8>::typed::dereference(o->arguments[8])), o); o->arguments[9] = (void*)info<T9>::typed::pointer(arg9); o->revisions[9] = info<T9>::typed::modify(const_cast<T9&>(info<T9>::typed::dereference(o->arguments[9])), o); ambient::controller.push(o); } static inline void invoke(sfunctor* o){ fp( info<T0>::typed::revised(o->arguments[0], o->revisions[0]) , info<T1>::typed::revised(o->arguments[1], o->revisions[1]) , info<T2>::typed::revised(o->arguments[2], o->revisions[2]) , info<T3>::typed::revised(o->arguments[3], o->revisions[3]) , info<T4>::typed::revised(o->arguments[4], o->revisions[4]) , info<T5>::typed::revised(o->arguments[5], o->revisions[5]) , info<T6>::typed::revised(o->arguments[6], o->revisions[6]) , info<T7>::typed::revised(o->arguments[7], o->revisions[7]) , info<T8>::typed::revised(o->arguments[8], o->revisions[8]) , marked info<T9>::typed::revised(o->arguments[9], o->revisions[9]) ); } static inline void cleanup(sfunctor* o){ info<T0>::typed::deallocate(o->arguments[0]); info<T1>::typed::deallocate(o->arguments[1]); info<T2>::typed::deallocate(o->arguments[2]); info<T3>::typed::deallocate(o->arguments[3]); info<T4>::typed::deallocate(o->arguments[4]); info<T5>::typed::deallocate(o->arguments[5]); info<T6>::typed::deallocate(o->arguments[6]); info<T7>::typed::deallocate(o->arguments[7]); info<T8>::typed::deallocate(o->arguments[8]); info<T9>::typed::deallocate(o->arguments[9]); } static inline void weight(cfunctor* o){ info<T0>::typed::weight(o->arguments[0], o); info<T1>::typed::weight(o->arguments[1], o); info<T2>::typed::weight(o->arguments[2], o); info<T3>::typed::weight(o->arguments[3], o); info<T4>::typed::weight(o->arguments[4], o); info<T5>::typed::weight(o->arguments[5], o); info<T6>::typed::weight(o->arguments[6], o); info<T7>::typed::weight(o->arguments[7], o); info<T8>::typed::weight(o->arguments[8], o); info<T9>::typed::weight(o->arguments[9], o); } static inline void place(sfunctor* o){ info<T0>::typed::place(o->arguments[0], o); info<T1>::typed::place(o->arguments[1], o); info<T2>::typed::place(o->arguments[2], o); info<T3>::typed::place(o->arguments[3], o); info<T4>::typed::place(o->arguments[4], o); info<T5>::typed::place(o->arguments[5], o); info<T6>::typed::place(o->arguments[6], o); info<T7>::typed::place(o->arguments[7], o); info<T8>::typed::place(o->arguments[8], o); info<T9>::typed::place(o->arguments[9], o); } static inline bool pretend(cfunctor* o){ return false; } static inline void l_check_complete(cfunctor* o){ o->check_complete(); } static inline void c_check_complete(cfunctor* o){ o->check_complete(); } };
