/*****************************************************************************
 *
 * ALPS MPS DMRG Project
 *
 * Copyright (C) 2014 Institute for Theoretical Physics, ETH Zurich
 *               2011-2013 by Michele Dolfi <dolfim@phys.ethz.ch>
 *               2020 by Leon Freitag <lefreita@ethz.ch>
 *
 * This software is part of the ALPS Applications, published under the ALPS
 * Application License; you can use, redistribute it and/or modify it under
 * the terms of the license, either version 1 or (at your option) any later
 * version.
 *
 * You should have received a copy of the ALPS Application License along with
 * the ALPS Applications; see the file LICENSE.txt. If not, the license is also
 * available from http://alps.comp-phys.org/.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *****************************************************************************/

#define BOOST_TEST_MAIN

#include <boost/test/included/unit_test.hpp>
#include "utils/fpcomparison.h"
#include "utils/io.hpp" // has to be first include because of impi
#include <iostream>


#include "maquis_dmrg.h"
// Test 1: H2 with d=3 Angstrom, singlet, cc-pVDZ basis set, CAS(2,2), integrals generated by MOLCAS
BOOST_AUTO_TEST_CASE( Test_4RDM_Save )
{

    DmrgParameters p;
    // // Integrals can be alternatively defined like this (as the FCIDUMP file without header)
    //
    const std::string integrals(
     "    1.63719990472             1     1     1     1\n"
     "  -0.144746632369             1     1     2     1\n"
     "   0.266282775636E-01         2     1     2     1\n"
     "   0.167531821030E-01         2     2     2     1\n"
     "   0.459207160088             1     1     2     2\n"
     "   0.533052674812             2     2     2     2\n"
     "   -0.230673683229E-01        1     1     3     1\n"
     "   0.873924303638E-02         2     1     3     1\n"
     "   0.212121998644E-01         2     2     3     1\n"
     "   0.517422983458E-02         3     1     3     1\n"
     "   0.166602690956E-01         3     2     3     1\n"
     "   0.201358122600E-01         3     3     3     1\n"
     "   0.113600263329             1     1     3     2\n"
     "   0.130338872974E-01         2     1     3     2\n"
     "   0.170776682916             2     2     3     2\n"
     "   0.130799970176             3     2     3     2\n"
     "   0.156301172407             3     3     3     2\n"
     "   0.386363318135             1     1     3     3\n"
     "   0.177101856628E-01         2     1     3     3\n"
     "   0.469384865605             2     2     3     3\n"
     "   0.439202823493             3     3     3     3\n"
     "   -4.96687194130             1     1     0     0\n"
     "   0.128261636279             2     1     0     0\n"
     "   -1.74403215804             2     2     0     0\n"
     "   -0.589618128664E-02        3     1     0     0\n"
     "   -0.377341184513            3     2     0     0\n"
     "   -1.09420984374             3     3     0     0\n"
     "   1.58753163271              0     0     0     0\n");


    p.set("integrals", integrals);


    p.set("site_types", "0,0,0");
    p.set("L", 3);
    p.set("irrep", 0);

    p.set("nsweeps",2);
    p.set("max_bond_dimension",100);

    // for SU2U1
    p.set("nelec", 4);
    p.set("spin", 0);

    // for 2U1

    p.set("u1_total_charge1", 2);
    p.set("u1_total_charge2", 2);

    // Measure 4-RDM
    p.set("MEASURE[4rdm]",1);
    // Measure 3-RDM
    p.set("MEASURE[3rdm]",1);
    // This is an expensive test, so we will run it only for one symmetry
    std::vector<std::string> symmetries;
    #ifdef HAVE_SU2U1PG
    symmetries.push_back("su2u1pg");
    #endif

    // #ifdef HAVE_SU2U1
    // symmetries.push_back("su2u1");
    // #endif
    // #ifdef HAVE_TwoU1PG
    // symmetries.push_back("2u1pg");
    // #endif
    // #ifdef HAVE_TwoU1
    // symmetries.push_back("2u1");
    // #endif

    for (auto&& s: symmetries)
    {
        maquis::cout << "Running test for symmetry " << s << std::endl;
        p.set("symmetry", s);

        maquis::DMRGInterface<double> interface(p);
        interface.optimize();

        BOOST_CHECK_CLOSE(interface.energy(), -7.8986766891097169 , 1e-7);

        // 4-RDM
        const typename maquis::DMRGInterface<double>::meas_with_results_type& meas = interface.fourrdm();

        // we don't have a map for the measurements yet, so we'll do it the stupid way
        double value = 0.0;

        for (int i = 0; i < meas.first.size(); i++)
            if (meas.first[i] == std::vector<int>{2,2,0,0,2,1,1,0})
            {
                value = meas.second[i];
                break;
            }

        BOOST_CHECK_CLOSE(value, -0.0001629623226497 , 1e-7);

        // 3-RDM
        const typename maquis::DMRGInterface<double>::meas_with_results_type& meas3 = interface.threerdm();

        for (int i = 0; i < meas3.first.size(); i++)
            if (meas3.first[i] == std::vector<int>{1,0,2,2,1,2})
            {
                value = meas3.second[i];
                break;
            }

        BOOST_CHECK_CLOSE(value, 0.0004443548698028, 1e-7);
    }


}

