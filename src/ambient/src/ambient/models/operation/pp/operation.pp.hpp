 #define marked NULL,
 #define pinned ambient::models::ambient_pin* ,
template< typename FP, typename T0 >
operation( FP logistics, FP computing, T0 &arg0 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 1;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 >
void prototype_template(void (*)( T0& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 >
void cleanup_template(void (*)( T0& )){
    info<T0>::typed::deallocate(this->arguments[0]);
}
template < typename T0 >
void creditup_template(void (*)( T0& )){
    info<T0>::typed::weight(this->arguments[0], this);
}
template < typename T0 >
void mark_pin(void (*)( T0& )){
    this->pin = NULL;
}
template < typename T0 >
void latch_revisions(void (*)( T0& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this);
}
template < typename T0 > void prototype_template(void (*)( pinned T0& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 > void cleanup_template(void (*)( pinned T0& )) { info<T0>::typed::deallocate(this->arguments[0]); } template < typename T0 > void creditup_template(void (*)( pinned T0& )) { info<T0>::typed::weight(this->arguments[0], this); } template < typename T0 > void mark_pin(void (*)( pinned T0& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 > void latch_revisions(void (*)( pinned T0& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); }
template< typename FP, typename T0 , typename T1 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 2;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 >
void prototype_template(void (*)( T0& , T1& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 >
void cleanup_template(void (*)( T0& , T1& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]);
}
template < typename T0 , typename T1 >
void creditup_template(void (*)( T0& , T1& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this);
}
template < typename T0 , typename T1 >
void mark_pin(void (*)( T0& , T1& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 >
void latch_revisions(void (*)( T0& , T1& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this);
}
template < typename T0 , typename T1 > void prototype_template(void (*)( pinned T0& , T1& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 > void cleanup_template(void (*)( pinned T0& , T1& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); } template < typename T0 , typename T1 > void creditup_template(void (*)( pinned T0& , T1& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); } template < typename T0 , typename T1 > void mark_pin(void (*)( pinned T0& , T1& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 > void latch_revisions(void (*)( pinned T0& , T1& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); } template < typename T0 , typename T1 > void prototype_template(void (*)( T0& , pinned T1& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 > void cleanup_template(void (*)( T0& , pinned T1& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); } template < typename T0 , typename T1 > void creditup_template(void (*)( T0& , pinned T1& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); } template < typename T0 , typename T1 > void mark_pin(void (*)( T0& , pinned T1& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 > void latch_revisions(void (*)( T0& , pinned T1& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 3;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 >
void prototype_template(void (*)( T0& , T1& , T2& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 >
void cleanup_template(void (*)( T0& , T1& , T2& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]);
}
template < typename T0 , typename T1 , typename T2 >
void creditup_template(void (*)( T0& , T1& , T2& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this);
}
template < typename T0 , typename T1 , typename T2 >
void mark_pin(void (*)( T0& , T1& , T2& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 >
void latch_revisions(void (*)( T0& , T1& , T2& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this);
}
template < typename T0 , typename T1 , typename T2 > void prototype_template(void (*)( pinned T0& , T1& , T2& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 > void cleanup_template(void (*)( pinned T0& , T1& , T2& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); } template < typename T0 , typename T1 , typename T2 > void creditup_template(void (*)( pinned T0& , T1& , T2& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); } template < typename T0 , typename T1 , typename T2 > void mark_pin(void (*)( pinned T0& , T1& , T2& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 > void latch_revisions(void (*)( pinned T0& , T1& , T2& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); } template < typename T0 , typename T1 , typename T2 > void prototype_template(void (*)( T0& , pinned T1& , T2& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 > void cleanup_template(void (*)( T0& , pinned T1& , T2& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); } template < typename T0 , typename T1 , typename T2 > void creditup_template(void (*)( T0& , pinned T1& , T2& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); } template < typename T0 , typename T1 , typename T2 > void mark_pin(void (*)( T0& , pinned T1& , T2& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 > void latch_revisions(void (*)( T0& , pinned T1& , T2& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); } template < typename T0 , typename T1 , typename T2 > void prototype_template(void (*)( T0& , T1& , pinned T2& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 > void cleanup_template(void (*)( T0& , T1& , pinned T2& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); } template < typename T0 , typename T1 , typename T2 > void creditup_template(void (*)( T0& , T1& , pinned T2& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); } template < typename T0 , typename T1 , typename T2 > void mark_pin(void (*)( T0& , T1& , pinned T2& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 > void latch_revisions(void (*)( T0& , T1& , pinned T2& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 , typename T3 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 , T3 &arg3 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 4;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2); this->arguments[3] = (void*)info<T3>::typed::pointer(arg3);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 , typename T3 >
void prototype_template(void (*)( T0& , T1& , T2& , T3& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& , T3& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 , typename T3 >
void cleanup_template(void (*)( T0& , T1& , T2& , T3& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]);
}
template < typename T0 , typename T1 , typename T2 , typename T3 >
void creditup_template(void (*)( T0& , T1& , T2& , T3& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 >
void mark_pin(void (*)( T0& , T1& , T2& , T3& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 , typename T3 >
void latch_revisions(void (*)( T0& , T1& , T2& , T3& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 > void prototype_template(void (*)( pinned T0& , T1& , T2& , T3& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& , T3& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 > void cleanup_template(void (*)( pinned T0& , T1& , T2& , T3& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); } template < typename T0 , typename T1 , typename T2 , typename T3 > void creditup_template(void (*)( pinned T0& , T1& , T2& , T3& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); } template < typename T0 , typename T1 , typename T2 , typename T3 > void mark_pin(void (*)( pinned T0& , T1& , T2& , T3& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 , typename T3 > void latch_revisions(void (*)( pinned T0& , T1& , T2& , T3& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 > void prototype_template(void (*)( T0& , pinned T1& , T2& , T3& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& , T3& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 > void cleanup_template(void (*)( T0& , pinned T1& , T2& , T3& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); } template < typename T0 , typename T1 , typename T2 , typename T3 > void creditup_template(void (*)( T0& , pinned T1& , T2& , T3& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); } template < typename T0 , typename T1 , typename T2 , typename T3 > void mark_pin(void (*)( T0& , pinned T1& , T2& , T3& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 , typename T3 > void latch_revisions(void (*)( T0& , pinned T1& , T2& , T3& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 > void prototype_template(void (*)( T0& , T1& , pinned T2& , T3& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& , T3& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 > void cleanup_template(void (*)( T0& , T1& , pinned T2& , T3& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); } template < typename T0 , typename T1 , typename T2 , typename T3 > void creditup_template(void (*)( T0& , T1& , pinned T2& , T3& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); } template < typename T0 , typename T1 , typename T2 , typename T3 > void mark_pin(void (*)( T0& , T1& , pinned T2& , T3& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 , typename T3 > void latch_revisions(void (*)( T0& , T1& , pinned T2& , T3& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 > void prototype_template(void (*)( T0& , T1& , T2& , pinned T3& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , pinned T3& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , marked info<T3>::typed::dereference(this->arguments[3]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 > void cleanup_template(void (*)( T0& , T1& , T2& , pinned T3& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); } template < typename T0 , typename T1 , typename T2 , typename T3 > void creditup_template(void (*)( T0& , T1& , T2& , pinned T3& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); } template < typename T0 , typename T1 , typename T2 , typename T3 > void mark_pin(void (*)( T0& , T1& , T2& , pinned T3& )) { this->pin = &current(info<T3>::typed::dereference(this->arguments[3])); } template < typename T0 , typename T1 , typename T2 , typename T3 > void latch_revisions(void (*)( T0& , T1& , T2& , pinned T3& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 , T3 &arg3 , T4 &arg4 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 5;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2); this->arguments[3] = (void*)info<T3>::typed::pointer(arg3); this->arguments[4] = (void*)info<T4>::typed::pointer(arg4);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& , T3& , T4& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 >
void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void prototype_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& , T3& , T4& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void cleanup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void creditup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void mark_pin(void (*)( pinned T0& , T1& , T2& , T3& , T4& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void latch_revisions(void (*)( pinned T0& , T1& , T2& , T3& , T4& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void prototype_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& , T3& , T4& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void cleanup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void creditup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void mark_pin(void (*)( T0& , pinned T1& , T2& , T3& , T4& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void latch_revisions(void (*)( T0& , pinned T1& , T2& , T3& , T4& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void prototype_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& , T3& , T4& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void cleanup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void creditup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void mark_pin(void (*)( T0& , T1& , pinned T2& , T3& , T4& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void latch_revisions(void (*)( T0& , T1& , pinned T2& , T3& , T4& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void prototype_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , pinned T3& , T4& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , marked info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void cleanup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void creditup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void mark_pin(void (*)( T0& , T1& , T2& , pinned T3& , T4& )) { this->pin = &current(info<T3>::typed::dereference(this->arguments[3])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void latch_revisions(void (*)( T0& , T1& , T2& , pinned T3& , T4& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , pinned T4& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , marked info<T4>::typed::dereference(this->arguments[4]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , pinned T4& )) { this->pin = &current(info<T4>::typed::dereference(this->arguments[4])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , pinned T4& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 , T3 &arg3 , T4 &arg4 , T5 &arg5 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 6;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2); this->arguments[3] = (void*)info<T3>::typed::pointer(arg3); this->arguments[4] = (void*)info<T4>::typed::pointer(arg4); this->arguments[5] = (void*)info<T5>::typed::pointer(arg5);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 >
void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void prototype_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void cleanup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void creditup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void mark_pin(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void latch_revisions(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void prototype_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void cleanup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void creditup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void mark_pin(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void latch_revisions(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void prototype_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void cleanup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void creditup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void mark_pin(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void latch_revisions(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void prototype_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , marked info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void cleanup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void creditup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void mark_pin(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& )) { this->pin = &current(info<T3>::typed::dereference(this->arguments[3])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void latch_revisions(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , marked info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& )) { this->pin = &current(info<T4>::typed::dereference(this->arguments[4])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , marked info<T5>::typed::dereference(this->arguments[5]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& )) { this->pin = &current(info<T5>::typed::dereference(this->arguments[5])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 , T3 &arg3 , T4 &arg4 , T5 &arg5 , T6 &arg6 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 7;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2); this->arguments[3] = (void*)info<T3>::typed::pointer(arg3); this->arguments[4] = (void*)info<T4>::typed::pointer(arg4); this->arguments[5] = (void*)info<T5>::typed::pointer(arg5); this->arguments[6] = (void*)info<T6>::typed::pointer(arg6);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 >
void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 >
void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 >
void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 >
void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 >
void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void prototype_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void cleanup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void creditup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void mark_pin(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void latch_revisions(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void prototype_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void cleanup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void creditup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void mark_pin(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void latch_revisions(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void prototype_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void cleanup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void creditup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void mark_pin(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void latch_revisions(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void prototype_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , marked info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void cleanup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void creditup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void mark_pin(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& )) { this->pin = &current(info<T3>::typed::dereference(this->arguments[3])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void latch_revisions(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , marked info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& )) { this->pin = &current(info<T4>::typed::dereference(this->arguments[4])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , marked info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& )) { this->pin = &current(info<T5>::typed::dereference(this->arguments[5])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , marked info<T6>::typed::dereference(this->arguments[6]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& )) { this->pin = &current(info<T6>::typed::dereference(this->arguments[6])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 , T3 &arg3 , T4 &arg4 , T5 &arg5 , T6 &arg6 , T7 &arg7 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 8;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2); this->arguments[3] = (void*)info<T3>::typed::pointer(arg3); this->arguments[4] = (void*)info<T4>::typed::pointer(arg4); this->arguments[5] = (void*)info<T5>::typed::pointer(arg5); this->arguments[6] = (void*)info<T6>::typed::pointer(arg6); this->arguments[7] = (void*)info<T7>::typed::pointer(arg7);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 >
void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 >
void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 >
void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 >
void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 >
void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , marked info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& )) { this->pin = &current(info<T3>::typed::dereference(this->arguments[3])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , marked info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& )) { this->pin = &current(info<T4>::typed::dereference(this->arguments[4])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , marked info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& )) { this->pin = &current(info<T5>::typed::dereference(this->arguments[5])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , marked info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& )) { this->pin = &current(info<T6>::typed::dereference(this->arguments[6])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , marked info<T7>::typed::dereference(this->arguments[7]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& )) { this->pin = &current(info<T7>::typed::dereference(this->arguments[7])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 , T3 &arg3 , T4 &arg4 , T5 &arg5 , T6 &arg6 , T7 &arg7 , T8 &arg8 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 9;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2); this->arguments[3] = (void*)info<T3>::typed::pointer(arg3); this->arguments[4] = (void*)info<T4>::typed::pointer(arg4); this->arguments[5] = (void*)info<T5>::typed::pointer(arg5); this->arguments[6] = (void*)info<T6>::typed::pointer(arg6); this->arguments[7] = (void*)info<T7>::typed::pointer(arg7); this->arguments[8] = (void*)info<T8>::typed::pointer(arg8);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 >
void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 >
void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 >
void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 >
void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 >
void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , marked info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& )) { this->pin = &current(info<T3>::typed::dereference(this->arguments[3])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , marked info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& )) { this->pin = &current(info<T4>::typed::dereference(this->arguments[4])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , marked info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& )) { this->pin = &current(info<T5>::typed::dereference(this->arguments[5])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , marked info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& )) { this->pin = &current(info<T6>::typed::dereference(this->arguments[6])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , marked info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& )) { this->pin = &current(info<T7>::typed::dereference(this->arguments[7])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , marked info<T8>::typed::dereference(this->arguments[8]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& )) { this->pin = &current(info<T8>::typed::dereference(this->arguments[8])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); }
template< typename FP, typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 >
operation( FP logistics, FP computing, T0 &arg0 , T1 &arg1 , T2 &arg2 , T3 &arg3 , T4 &arg4 , T5 &arg5 , T6 &arg6 , T7 &arg7 , T8 &arg8 , T9 &arg9 ){
    this->logistics_ptr = (void(*)())logistics;
    this->computing_ptr = (void(*)())computing;
    this->op = (void(*)())computing;
    this->workload = 0;
    this->credit = 0;
    this->count = 10;
    this->state = MARKUP;
    this->arguments = (void**)malloc(sizeof(void*)*this->count);
    this->revisions = (size_t*)malloc(sizeof(size_t)*this->count);
    this->arguments[0] = (void*)info<T0>::typed::pointer(arg0); this->arguments[1] = (void*)info<T1>::typed::pointer(arg1); this->arguments[2] = (void*)info<T2>::typed::pointer(arg2); this->arguments[3] = (void*)info<T3>::typed::pointer(arg3); this->arguments[4] = (void*)info<T4>::typed::pointer(arg4); this->arguments[5] = (void*)info<T5>::typed::pointer(arg5); this->arguments[6] = (void*)info<T6>::typed::pointer(arg6); this->arguments[7] = (void*)info<T7>::typed::pointer(arg7); this->arguments[8] = (void*)info<T8>::typed::pointer(arg8); this->arguments[9] = (void*)info<T9>::typed::pointer(arg9);
    this->mark_pin(logistics);
    this->latch_revisions(logistics);
    void(operation::*ptr)(FP); ptr = &operation::prototype_template;
    this->prototype = (void(operation::*)())ptr;
    ptr = &operation::cleanup_template;
    this->cleanup = (void(operation::*)())ptr;
    ptr = &operation::creditup_template;
    this->creditup = (void(operation::*)())ptr;
    pthread_mutex_init(&this->mutex, NULL);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 >
void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )){
    info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]);
    void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; }
    ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) fp )
    ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) );
    pthread_mutex_lock(&this->mutex);
    if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square();
    else this->workload--;
    if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); }
    pthread_mutex_unlock(&this->mutex);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 >
void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )){
    info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 >
void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )){
    info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 >
void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )){
    this->pin = NULL;
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 >
void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )){
    this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this);
}
template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) fp ) ( marked info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->pin = &current(info<T0>::typed::dereference(this->arguments[0])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( pinned T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , marked info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->pin = &current(info<T1>::typed::dereference(this->arguments[1])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , pinned T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , marked info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->pin = &current(info<T2>::typed::dereference(this->arguments[2])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , pinned T2& , T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , marked info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->pin = &current(info<T3>::typed::dereference(this->arguments[3])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , T2& , pinned T3& , T4& , T5& , T6& , T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , marked info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& )) { this->pin = &current(info<T4>::typed::dereference(this->arguments[4])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , pinned T4& , T5& , T6& , T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , marked info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& )) { this->pin = &current(info<T5>::typed::dereference(this->arguments[5])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , pinned T5& , T6& , T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , marked info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& )) { this->pin = &current(info<T6>::typed::dereference(this->arguments[6])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , pinned T6& , T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , marked info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& )) { this->pin = &current(info<T7>::typed::dereference(this->arguments[7])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , pinned T7& , T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , marked info<T8>::typed::dereference(this->arguments[8]) , info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& )) { this->pin = &current(info<T8>::typed::dereference(this->arguments[8])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , pinned T8& , T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void prototype_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& )) { info<T0>::typed::revise(this->arguments[0], this->revisions[0]); info<T1>::typed::revise(this->arguments[1], this->revisions[1]); info<T2>::typed::revise(this->arguments[2], this->revisions[2]); info<T3>::typed::revise(this->arguments[3], this->revisions[3]); info<T4>::typed::revise(this->arguments[4], this->revisions[4]); info<T5>::typed::revise(this->arguments[5], this->revisions[5]); info<T6>::typed::revise(this->arguments[6], this->revisions[6]); info<T7>::typed::revise(this->arguments[7], this->revisions[7]); info<T8>::typed::revise(this->arguments[8], this->revisions[8]); info<T9>::typed::revise(this->arguments[9], this->revisions[9]); void(*fp)() = this->op; if(this->state == MARKUP){ this->state = COMPUTING; fp = this->logistics_ptr; } ( (void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& )) fp ) ( info<T0>::typed::dereference(this->arguments[0]) , info<T1>::typed::dereference(this->arguments[1]) , info<T2>::typed::dereference(this->arguments[2]) , info<T3>::typed::dereference(this->arguments[3]) , info<T4>::typed::dereference(this->arguments[4]) , info<T5>::typed::dereference(this->arguments[5]) , info<T6>::typed::dereference(this->arguments[6]) , info<T7>::typed::dereference(this->arguments[7]) , info<T8>::typed::dereference(this->arguments[8]) , marked info<T9>::typed::dereference(this->arguments[9]) ); pthread_mutex_lock(&this->mutex); if(fp == this->logistics_ptr) this->workload += this->pin->get_layout().get_grid_dim().square(); else this->workload--; if(this->workload == 0){ this->state = COMPLETE; controller.atomic_complete(); } pthread_mutex_unlock(&this->mutex); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void cleanup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& )) { info<T0>::typed::deallocate(this->arguments[0]); info<T1>::typed::deallocate(this->arguments[1]); info<T2>::typed::deallocate(this->arguments[2]); info<T3>::typed::deallocate(this->arguments[3]); info<T4>::typed::deallocate(this->arguments[4]); info<T5>::typed::deallocate(this->arguments[5]); info<T6>::typed::deallocate(this->arguments[6]); info<T7>::typed::deallocate(this->arguments[7]); info<T8>::typed::deallocate(this->arguments[8]); info<T9>::typed::deallocate(this->arguments[9]); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void creditup_template(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& )) { info<T0>::typed::weight(this->arguments[0], this); info<T1>::typed::weight(this->arguments[1], this); info<T2>::typed::weight(this->arguments[2], this); info<T3>::typed::weight(this->arguments[3], this); info<T4>::typed::weight(this->arguments[4], this); info<T5>::typed::weight(this->arguments[5], this); info<T6>::typed::weight(this->arguments[6], this); info<T7>::typed::weight(this->arguments[7], this); info<T8>::typed::weight(this->arguments[8], this); info<T9>::typed::weight(this->arguments[9], this); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void mark_pin(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& )) { this->pin = &current(info<T9>::typed::dereference(this->arguments[9])); } template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > void latch_revisions(void (*)( T0& , T1& , T2& , T3& , T4& , T5& , T6& , T7& , T8& , pinned T9& )) { this->revisions[0] = info<T0>::typed::modify(info<T0>::typed::dereference(this->arguments[0]), this); this->revisions[1] = info<T1>::typed::modify(info<T1>::typed::dereference(this->arguments[1]), this); this->revisions[2] = info<T2>::typed::modify(info<T2>::typed::dereference(this->arguments[2]), this); this->revisions[3] = info<T3>::typed::modify(info<T3>::typed::dereference(this->arguments[3]), this); this->revisions[4] = info<T4>::typed::modify(info<T4>::typed::dereference(this->arguments[4]), this); this->revisions[5] = info<T5>::typed::modify(info<T5>::typed::dereference(this->arguments[5]), this); this->revisions[6] = info<T6>::typed::modify(info<T6>::typed::dereference(this->arguments[6]), this); this->revisions[7] = info<T7>::typed::modify(info<T7>::typed::dereference(this->arguments[7]), this); this->revisions[8] = info<T8>::typed::modify(info<T8>::typed::dereference(this->arguments[8]), this); this->revisions[9] = info<T9>::typed::modify(info<T9>::typed::dereference(this->arguments[9]), this); }
 #undef marked
 #undef pinned
