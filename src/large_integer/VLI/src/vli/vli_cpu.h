/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Timothee Ewart - University of Geneva,
*Andreas Hehn - Swiss Federal Institute of technology Zurich.
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#ifndef VLI_NUMBER_CPU_HPP
#define VLI_NUMBER_CPU_HPP
#include "vli/detail/bit_masks.hpp"
#include "vli/function_hooks/vli_number_cpu_function_hooks.hpp"
#include <boost/lexical_cast.hpp>
#include <vector>
#include <string>
#include <cassert>
#include <cstring>
#include <ostream>
#include <sstream>
#include <boost/swap.hpp>


namespace vli{
    
    template<typename BaseInt, std::size_t Size>
    void swap(vli_cpu<BaseInt,Size>& a, vli_cpu<BaseInt,Size>& b){
        boost::swap(a.data_,b.data_);
    }
    
    template<class BaseInt, std::size_t Size>
    class vli_cpu 
    {
    public:
        typedef BaseInt         value_type;     // Data type to store parts of the very long integer (usually int) -
        typedef std::size_t     size_type;      // Size type of the very long integers (number of parts)
        enum {size = Size};                     // Number of parts of the very long integer (eg. how many ints)
        // c - constructors, copy-swap, access   
        vli_cpu();
        explicit vli_cpu(int num);
        vli_cpu(vli_cpu const& r);
#if defined __GNU_MP_VERSION
        // TODO find a better solution for this.
        operator mpz_class() const;
        operator mpq_class() const;
#endif //__GNU_MP_VERSION
        friend void swap<> (vli_cpu& a, vli_cpu& b);
        vli_cpu& operator= (vli_cpu r);
        BaseInt& operator[](size_type i);
        const BaseInt& operator[](size_type i) const;
        // c - negative number
        void negate();
        bool is_negative() const;
        // c - basic operator
        vli_cpu& operator += (vli_cpu const& vli);        
        vli_cpu& operator += (BaseInt const a);
        vli_cpu& operator -= (vli_cpu const& vli);
        vli_cpu& operator -= (BaseInt a);
        vli_cpu& operator *= (BaseInt a); // 192 bits -> 192 bits
        vli_cpu& operator *= (vli_cpu const& a); // 192 bits -> 192 bits
        
        vli_cpu operator -() const;
        bool operator == (vli_cpu const& vli) const;
        bool operator != (vli_cpu const& vli) const;
        bool operator < (vli_cpu const& vli) const;
        bool operator < (int i) const;
        bool operator > (vli_cpu vli) const;
        bool operator > (int i) const;
        bool is_zero() const;
        void print_raw(std::ostream& os) const;
        void print(std::ostream& os) const;
        
        std::string get_str() const;
        size_type order_of_magnitude_base10(vli_cpu<BaseInt,size> const& value) const;
        std::string get_str_helper_inplace(vli_cpu<BaseInt,size>& value, size_type ten_exp) const;
    private:
        BaseInt data_[Size];
    };

    template <class BaseInt, std::size_t Size>
    class extend_helper {
    };
    
    /**
     multiply and addition operators, suite ...
     */
    template <class BaseInt, std::size_t Size>
    bool is_zero(vli_cpu<BaseInt, Size> const& v);
    
    template <class BaseInt, std::size_t Size>
    void negate_inplace(vli_cpu<BaseInt, Size>& v);

    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator + (vli_cpu<BaseInt, Size> vli_a, vli_cpu<BaseInt, Size> const& vli_b);

    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator + (vli_cpu<BaseInt, Size> vli_a, int b);
    
    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator + (int b, vli_cpu<BaseInt, Size> const& vli_a);
    
    template <class BaseInt, std::size_t Size> //extented arithmetic
    const vli_cpu<BaseInt, Size+1> plus_extend(vli_cpu<BaseInt, Size> const& vli_a, vli_cpu<BaseInt, Size> const& vli_b);

    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator - (vli_cpu<BaseInt, Size> vli_a, vli_cpu<BaseInt, Size> const& vli_b);
    
    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator - (vli_cpu<BaseInt, Size> vli_a, int b);
    
    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator * (vli_cpu<BaseInt, Size>  vli_a, vli_cpu<BaseInt, Size> const& vli_b);

    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator * (vli_cpu<BaseInt, Size> vli_a, int b);

    template <class BaseInt, std::size_t Size>
    const vli_cpu<BaseInt, Size> operator * (int b, vli_cpu<BaseInt, Size> const& a);

    template <class BaseInt, std::size_t Size>
    void mul(vli_cpu<BaseInt, 2*Size>& vli_res, vli_cpu<BaseInt, Size> const&  vli_a, vli_cpu<BaseInt, Size> const& vli_b); // C nt = non truncated

    template <class BaseInt, std::size_t Size>
    void multiply_add(vli_cpu<BaseInt, 2*Size>& vli_res, vli_cpu<BaseInt, Size> const&  vli_a, vli_cpu<BaseInt, Size> const& vli_b); // C
    /**
    stream 
    */
    template<typename BaseInt, std::size_t Size>
    std::ostream& operator<< (std::ostream& os,  vli_cpu<BaseInt, Size> const& vli);
}

#include "vli/vli_cpu.hpp"

#endif //VLI_NUMBER_CPU_HPP
