/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Timothee Ewart - University of Geneva, 
*Andreas Hehn - Swiss Federal Institute of technology Zurich.
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#ifndef VLI_polynomial_FUNCTION_HOOKS_HPP
#define VLI_polynomial_FUNCTION_HOOKS_HPP

#include "vli/polynomial/algorithms_polynomial.hpp"
#include "vli/vli_cpu.h"

namespace vli{

template<class Vli, unsigned int Order>
class polynomial;
   
template<class Vli>
struct monomial;

template<class BaseInt, std::size_t Size>
class vli_cpu;
    
/** Algo based on triangle + diagnoal decomposition, nthreads maximum **/
template <class BaseInt, std::size_t Size, unsigned int Order>
void poly_multiply_block_algo(polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result, 
                        polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                        polynomial<vli_cpu<BaseInt, Size>, Order> const & p2) {
    // first PASS, half top right corner, 
    unsigned int n(0);
    for(unsigned int i=0;i< Order;++i){ // i will be a thread here, independence loop
        for(unsigned int j=0; j<=n; ++j){
            block_algo(j,n-j,result,p1,p2);
        }
        n++; // thread num
    }
    
    // second PASS, half bottom left corner, 
    n=1;
    for(unsigned int i=1; i<Order;++i){  // i will be a thread here, independence loop
        for(unsigned int j=n; j<Order; ++j){
            block_algo(j,Order-j+n-1,result,p1,p2);
        }
        n++; // thread num
    }
}
    
/** Algo based on diagonal decomposition, nthreads*nthreads maximum **/    
template <class BaseInt, std::size_t Size, unsigned int Order>
void poly_multiply_diag_algo(polynomial<vli_cpu<BaseInt, 2*Size>, 2*Order> & result, 
                             polynomial<vli_cpu<BaseInt, Size>, Order> const & p1, 
                             polynomial<vli_cpu<BaseInt, Size>, Order> const & p2) {   
    //first pass
    for(unsigned int i(0); i < Order*Order ; ++i)
        diagonal_up(i,result,p1,p2);
    //second pass    
    for(unsigned int i(0); i < Order*Order ; ++i)
        diagonal_down(Order*Order - i,result,p1,p2); 
        
}
    
    
    
        
}// end namespace 

#endif
