/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Timothee Ewart - University of Geneva, 
*Andreas Hehn - Swiss Federal Institute of technology Zurich.
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#ifndef COMMON_TEST_FUNCTIONS_HPP
#define COMMON_TEST_FUNCTIONS_HPP

#include <boost/mpl/list.hpp>
#include <boost/mpl/pop_front.hpp>

#include <boost/preprocessor/tuple/elem.hpp>
#include <boost/preprocessor/seq/for_each.hpp>

#include <boost/random/mersenne_twister.hpp>
#include <boost/random/uniform_int.hpp>

#include "vli/vli_config.h"
#include "vli/vli_traits.hpp"


namespace vli
{
template <class T>
struct iterator;

namespace test
{


//
// Generate a list of all vli types for which the library was compiled
// and run tests for them.
// (VLI_COMPILE_BASEINT_SIZE_PAIRS_SEQ is defined by CMake
//  in vli_utils/vli_config.h)
//

#define VLI_CPU_APPEND_TEST_TYPE(r,data,BASEINT_SIZE_ORDER_TUPLE) \
        , vli_cpu< BOOST_PP_TUPLE_ELEM(3,0,BASEINT_SIZE_ORDER_TUPLE ) , BOOST_PP_TUPLE_ELEM(3,1,BASEINT_SIZE_ORDER_TUPLE ) >

typedef boost::mpl::pop_front<
    boost::mpl::list<
        boost::mpl::void_
BOOST_PP_SEQ_FOR_EACH(VLI_CPU_APPEND_TEST_TYPE, _, VLI_COMPILE_BASEINT_SIZE_ORDER_TUPLE_SEQ )
    >
>::type vli_cpu_type_list;
// I could boost pp
typedef boost::mpl::list< vli::vli_cpu <unsigned long int, 2>,
                          vli::vli_cpu <unsigned long int, 3>, 
                          vli::vli_cpu <unsigned long int, 4>, 
                          vli::vli_cpu <unsigned long int, 5>, 
                          vli::vli_cpu <unsigned long int, 6>, 
                          vli::vli_cpu <unsigned long int, 7> 
                        > vli_cpu_type_extented_list;

typedef boost::mpl::list< vli::vli_cpu <unsigned long int, 2>,
                          vli::vli_cpu <unsigned long int, 3>,
                          vli::vli_cpu <unsigned long int, 4>
                        > vli_cpu_type_extented_list_two;
boost::mt11213b rng;

template <typename Vli>
typename Vli::value_type rnd_digit(){
  //  static boost::uniform_int<typename Vli::value_type> rnd(0,max_int_value<Vli>::value);
    return rand()%max_int_value<Vli>::value  ;//rnd(rng);
}

template <typename Vli>
int rnd_valid_int(){
 //   static boost::uniform_int<int> rnd(0,std::abs(static_cast<int>(max_int_value<Vli>::value)));
    return rand()%max_int_value<Vli>::value  ;
//    return rnd(rng);
}

template <typename Vli>
void vli_negate(Vli& v, int random){
    if(v[0]%random == 0)
        v.negate();
}

template <typename Vli>
void fill_random(Vli& v){
    for(typename Vli::size_type i=0; i < Vli::size; ++i)
        v[i] = rnd_digit<Vli>();
}

template <typename Vli>
void fill_random(Vli& v, typename Vli::size_type size){
    assert(size <= Vli::size);
    for(typename Vli::size_type i=0; i < size; ++i)
        v[i] = rnd_digit<Vli>();
}

template <typename Polynomial>
void fill_poly_random(Polynomial& p){
    for(typename Polynomial::exponent_type i=0; i < Polynomial::max_order; ++i)
        for(typename Polynomial::exponent_type j=0; j < Polynomial::max_order; ++j)
            fill_random(p(i,j),2);
}

template <typename Polynomial>
void fill_poly_random(Polynomial& p, typename Polynomial::exponent_type size){
    for(typename vli::iterator<Polynomial>::type it= p.begin(); it != p.end(); ++it)
        fill_random(*it,size);
}

template <typename Polynomial>
void fill_poly_negate(Polynomial& p, int random){
    //TODO remove?
    for(typename vli::iterator<Polynomial>::type it= p.begin(); it != p.end(); ++it)
        vli_negate(*it,random);
}
    
template <typename Vector>
void fill_vector_random(Vector& v){
    for(typename Vector::size_type i=0; i < v.size(); ++i)
        fill_poly_random(v[i]);
}

template <typename Vector>
void fill_vector_random(Vector& v, typename Vector::value_type::exponent_type size){
    for(typename Vector::size_type i=0; i < v.size(); ++i)
        fill_poly_random(v[i], size);
}

template <typename Vector>
void fill_vector_negate(Vector& v,int random){
    for(typename Vector::size_type i=0; i < v.size(); ++i)
        fill_poly_negate(v[i], random);
    
}
    
template<typename PolynomialVLI, typename PolynomialGMP>
void InitPolyVLItoPolyGMP(PolynomialVLI const& P1, PolynomialGMP& P2){
    int max_order = PolynomialGMP::order_cutoff;

    for(long int j = 0; j < max_order; j++)
        for(long int k = 0; k < max_order; k++)
            P2(j,k) = P1(j,k).get_str();
}

template <typename VpolyVLI, typename VpolyGMP>
void InitVecVLItoVecGMP(VpolyVLI const& VVLI, VpolyGMP & VGMP){
    #pragma omp parallel for 
    for (long int i =0 ; i < (long int)VVLI.size(); ++i)
        InitPolyVLItoPolyGMP(VVLI[i],VGMP[i]);
}


} //namespace test
} //namespace vli

#endif //COMMON_TEST_FUNCTIONS_HPP
