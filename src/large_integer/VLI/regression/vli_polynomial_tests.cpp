/*
*Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
*
*Timothee Ewart - University of Geneva, 
*Andreas Hehn - Swiss Federal Institute of technology Zurich.
*
*Permission is hereby granted, free of charge, to any person or organization
*obtaining a copy of the software and accompanying documentation covered by
*this license (the "Software") to use, reproduce, display, distribute,
*execute, and transmit the Software, and to prepare derivative works of the
*Software, and to permit third-parties to whom the Software is furnished to
*do so, all subject to the following:
*
*The copyright notices in the Software and this entire statement, including
*the above license grant, this restriction and the following disclaimer,
*must be included in all copies of the Software, in whole or in part, and
*all derivative works of the Software, unless such copies or derivative
*works are solely in the form of machine-executable object code generated by
*a source language processor.
*
*THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
*SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
*FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
*ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*DEALINGS IN THE SOFTWARE.
*/

#define BOOST_TEST_MODULE vli_polynomial
#include <boost/test/unit_test.hpp>
#include <boost/mpl/transform.hpp>
#include <boost/static_assert.hpp>

#include "vli/polynomial/monomial.hpp"
#include "vli/polynomial/polynomial.hpp"
#include "vli/vli_cpu.h"

#include "regression/vli_test.hpp"

using vli::test::fill_random;
using vli::test::fill_poly_random;
using vli::vli_cpu;
using vli::monomial;
using vli::polynomial;

template <typename Vli>
struct polynomial_from_vli_cpu
{
    typedef polynomial<Vli, 10> type;
};

typedef boost::mpl::transform<
      vli::test::vli_cpu_type_extented_list
    , polynomial_from_vli_cpu<boost::mpl::_1>
    >::type polynomial_types_extented;
        
typedef boost::mpl::transform<
      vli::test::vli_cpu_type_extented_list_two
    , polynomial_from_vli_cpu<boost::mpl::_1>
    >::type polynomial_types_extented_two;

BOOST_AUTO_TEST_CASE_TEMPLATE( construction_and_coeff_assignment, Poly, polynomial_types_extented )
{
    Poly pa;
    typedef typename Poly::exponent_type exponent_type;
    typename Poly::value_type a[Poly::max_order*Poly::max_order];

    for(exponent_type i=0; i < Poly::max_order; ++i)
        for(exponent_type j=0; j < Poly::max_order; ++j)
            BOOST_CHECK_EQUAL(pa(i,j), typename Poly::value_type(0));

    for(exponent_type i=0; i < Poly::max_order; ++i)
    {
        for(exponent_type j=0; j < Poly::max_order; ++j)
        {
            fill_random(a[i*Poly::max_order+j]);
            pa(i,j) = a[i*Poly::max_order+j];
        }
    }

    for(exponent_type i=0; i < Poly::max_order; ++i)
        for(exponent_type j=0; j < Poly::max_order; ++j)
            BOOST_CHECK_EQUAL(pa(i,j),a[i*Poly::max_order+j]);
}



BOOST_AUTO_TEST_CASE_TEMPLATE( multiplies, Poly, polynomial_types_extented_two )
{   
    //TODO fix types
    typedef vli::vli_cpu<typename Poly::value_type::size_type, 2*(Poly::value_type::size) > vli_result_type_cpu;
    typedef vli::vli_cpu<typename Poly::value_type::size_type, (Poly::value_type::size) > vli_type_cpu;    
    typedef vli::polynomial<vli_result_type_cpu, 2*(Poly::max_order) > polynomial_result_type_cpu;
    typedef vli::polynomial<vli_type_cpu, (Poly::max_order) > polynomial_type_cpu;
    
    polynomial_result_type_cpu pc;
    polynomial_type_cpu pa;
    fill_poly_random(pa);

    polynomial_type_cpu pb;
    fill_poly_random(pb);
   // poly_multiply(pc,pa,pb);
    pc = pa*pb;

    polynomial_result_type_cpu result;
    for(typename Poly::exponent_type i=0; i < Poly::max_order; ++i)
        for(typename Poly::exponent_type j=0; j < Poly::max_order; ++j)
            for(typename Poly::exponent_type k=0; k < (Poly::max_order ); ++k)
                for(typename Poly::exponent_type l=0; l < (Poly::max_order); ++l)
                    muladd(result(i+k,j+l),pa(i,j),pb(k,l));

    BOOST_CHECK_EQUAL(pc,result);    

 }

BOOST_AUTO_TEST_CASE_TEMPLATE( multiplies_keep_order, Poly, polynomial_types_extented_two )
{   
    //TODO fix types
    typedef vli::vli_cpu<typename Poly::value_type::size_type, 2*(Poly::value_type::size) > vli_result_type_cpu;
    typedef vli::vli_cpu<typename Poly::value_type::size_type, (Poly::value_type::size) > vli_type_cpu;    
    typedef vli::polynomial<vli_result_type_cpu, (Poly::max_order) > polynomial_result_type_cpu;
    typedef vli::polynomial<vli_type_cpu, (Poly::max_order) > polynomial_type_cpu;
    
    polynomial_result_type_cpu pc;
    polynomial_type_cpu pa;
    fill_poly_random(pa);

    polynomial_type_cpu pb;
    fill_poly_random(pb);
    pc = multiply_keep_order(pa,pb);

    polynomial_result_type_cpu result;
    for(typename Poly::exponent_type i=0; i < Poly::max_order; ++i)
        for(typename Poly::exponent_type j=0; j < Poly::max_order; ++j)
            for(typename Poly::exponent_type k=0; k < (Poly::max_order)-i; ++k)
                for(typename Poly::exponent_type l=0; l < (Poly::max_order)-j; ++l)
                    muladd(result(i+k,j+l),pa(i,j),pb(k,l));

    BOOST_CHECK_EQUAL(pc,result);    

 }

